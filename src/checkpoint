global BYTE_SHIFT: [Field; 32] = [
        1,
        0x1000000000000000000000000000000000000000000000000000000000000,
        0x10000000000000000000000000000000000000000000000000000000000,
        0x100000000000000000000000000000000000000000000000000000000,
        0x1000000000000000000000000000000000000000000000000000000,
        0x10000000000000000000000000000000000000000000000000000,
        0x100000000000000000000000000000000000000000000000000,
        0x1000000000000000000000000000000000000000000000000,
        0x10000000000000000000000000000000000000000000000,
        0x100000000000000000000000000000000000000000000,
        0x1000000000000000000000000000000000000000000,
        0x10000000000000000000000000000000000000000,
        0x100000000000000000000000000000000000000,
        0x1000000000000000000000000000000000000,
        0x10000000000000000000000000000000000,
        0x100000000000000000000000000000000,
        0x1000000000000000000000000000000,
        0x10000000000000000000000000000,
        0x100000000000000000000000000,
        0x1000000000000000000000000,
        0x10000000000000000000000,
        0x100000000000000000000,
        0x1000000000000000000,
        0x10000000000000000,
        0x100000000000000,
        0x1000000000000,
        0x10000000000,
        0x100000000,
        0x1000000,
        0x10000,
        0x100,
        1
    ];

global PATH_LOOKUP: [[bool; 5]; 32] = [
        [false, false, false, false, false],
        [true, false, false, false, false],
        [false, true, false, false, false],
        [true, true, false, false, false],
        [false, false, true, false, false],
        [true, false, true, false, false],
        [false, true, true, false, false],
        [true, true, true, false, false],
        [false, false, false, true, false],
        [true, false, false, true, false],
        [false, true, false, true, false],
        [true, true, false, true, false],
        [false, false, true, true, false],
        [true, false, true, true, false],
        [false, true, true, true, false],
        [true, true, true, true, false],
        [false, false, false, false, true],
        [true, false, false, false, true],
        [false, true, false, false, true],
        [true, true, false, false, true],
        [false, false, true, false, true],
        [true, false, true, false, true],
        [false, true, true, false, true],
        [true, true, true, false, true],
        [false, false, false, true, true],
        [true, false, false, true, true],
        [false, true, false, true, true],
        [true, true, false, true, true],
        [false, false, true, true, true],
        [true, false, true, true, true],
        [false, true, true, true, true],
        [true, true, true, true, true]
    ];

unconstrained fn __slice_field(f: Field, num_bytes: Field) -> [Field; 5] {
    let head_path = PATH_LOOKUP[num_bytes];

    let bytes = f.to_be_bytes(32);
    let bytes = bytes.map(|b| b as Field);

    let mut chunks: [Field; 5] = [0; 5];
    let mut head_ptr = 1;
    let mut tail_ptr = num_bytes + 1;
    if head_path[0] {
        chunks[0] = bytes[head_ptr] as Field;
        head_ptr += 1;
    } else {
        chunks[0] = bytes[tail_ptr] as Field;
        tail_ptr += 1;
    }
    if head_path[1] {
        chunks[1] = bytes[head_ptr] * 0x100 + bytes[head_ptr + 1];
        head_ptr += 2;
    } else {
        chunks[1] = bytes[tail_ptr] * 0x100 + bytes[tail_ptr + 1];
        tail_ptr += 2;
    }
    if head_path[2] {
        chunks[2] = bytes[head_ptr] * 0x1000000 + bytes[head_ptr + 1] * 0x10000
        + bytes[head_ptr + 2] * 0x100 + bytes[head_ptr + 3];
        head_ptr += 4;
    } else {
        chunks[2] = bytes[tail_ptr] * 0x1000000 + bytes[tail_ptr + 1] * 0x10000
        + bytes[tail_ptr + 2] * 0x100 + bytes[tail_ptr + 3];
        tail_ptr += 4;
    }
    if head_path[3] {
        chunks[3] = 
        bytes[head_ptr] * 0x100000000000000 + bytes[head_ptr + 1] * 0x1000000000000
        + bytes[head_ptr + 2] * 0x10000000000 + bytes[head_ptr + 3] * 0x100000000
        + bytes[head_ptr + 4] * 0x1000000 + bytes[head_ptr + 5] * 0x10000
        + bytes[head_ptr + 6] * 0x100 + bytes[head_ptr + 7];
        head_ptr += 8;
    } else {
        chunks[3] = 
        bytes[tail_ptr] * 0x100000000000000 + bytes[tail_ptr + 1] * 0x1000000000000
        + bytes[tail_ptr + 2] * 0x10000000000 + bytes[tail_ptr + 3] * 0x100000000
        + bytes[tail_ptr + 4] * 0x1000000 + bytes[tail_ptr + 5] * 0x10000
        + bytes[tail_ptr + 6] * 0x100 + bytes[tail_ptr + 7];
        tail_ptr += 8;
    }
    if head_path[4] {
        chunks[4] = 
        bytes[head_ptr] *       0x1000000000000000000000000000000 + bytes[head_ptr + 1] * 0x10000000000000000000000000000
        + bytes[head_ptr + 2] * 0x100000000000000000000000000 + bytes[head_ptr + 3] *      0x1000000000000000000000000
        + bytes[head_ptr + 4] * 0x10000000000000000000000 + bytes[head_ptr + 5] * 0x100000000000000000000
        + bytes[head_ptr + 6] * 0x1000000000000000000 + bytes[head_ptr + 7] * 0x10000000000000000
        + bytes[head_ptr + 8] * 0x100000000000000 + bytes[head_ptr + 9] * 0x1000000000000
        + bytes[head_ptr + 10] * 0x10000000000 + bytes[head_ptr + 11] * 0x100000000
        + bytes[head_ptr + 12] * 0x1000000 + bytes[head_ptr + 13] * 0x10000
        + bytes[head_ptr + 14] * 0x100 + bytes[head_ptr + 15];
    } else {
        chunks[4] = 
        bytes[tail_ptr] * 0x1000000000000000000000000000000 + bytes[tail_ptr + 1] * 0x10000000000000000000000000000
        + bytes[tail_ptr + 2] * 0x100000000000000000000000000 + bytes[tail_ptr + 3] * 0x1000000000000000000000000
        + bytes[tail_ptr + 4] * 0x10000000000000000000000 + bytes[tail_ptr + 5] * 0x100000000000000000000
        + bytes[tail_ptr + 6] * 0x1000000000000000000 + bytes[tail_ptr + 7] * 0x10000000000000000
        + bytes[tail_ptr + 8] * 0x100000000000000 + bytes[tail_ptr + 9] * 0x1000000000000
        + bytes[tail_ptr + 10] * 0x10000000000 + bytes[tail_ptr + 11] * 0x100000000
        + bytes[tail_ptr + 12] * 0x1000000 + bytes[tail_ptr + 13] * 0x10000
        + bytes[tail_ptr + 14] * 0x100 + bytes[tail_ptr + 15];
    }

    chunks
}

global two_pow_128 = 0x100000000000000000000000000000000;
global two_pow_64 = 0x10000000000000000;
global two_pow_32 = 0x100000000;
global two_pow_16 = 0x10000;

global path_multipliers_chunk4: [Field; 32] = [
    /* 0  (00000) */ 0,
    /* 1  (00001) */ 0,
    /* 2  (00010) */ 0,
    /* 3  (00011) */ 0,
    /* 4  (00100) */ 0,
    /* 5  (00101) */ 0,
    /* 6  (00110) */ 0,
    /* 7  (00111) */ 0,
    /* 8  (01000) */ 0,
    /* 9  (01001) */ 0,
    /* 10 (01010) */ 0,
    /* 11 (01011) */ 0,
    /* 12 (01100) */ 0,
    /* 13 (01101) */ 0,
    /* 14 (01110) */ 0,
    /* 15 (01111) */ 0,
    /* 16 (10000) */ 1,
    /* 17 (10001) */ 1,
    /* 18 (10010) */ 1,
    /* 19 (10011) */ 1,
    /* 20 (10100) */ 1,
    /* 21 (10101) */ 1,
    /* 22 (10110) */ 1,
    /* 23 (10111) */ 1,
    /* 24 (11000) */ 1,
    /* 25 (11001) */ 1,
    /* 26 (11010) */ 1,
    /* 27 (11011) */ 1,
    /* 28 (11100) */ 1,
    /* 29 (11101) */ 1,
    /* 30 (11110) */ 1,
    /* 31 (11111) */ 1
];

// this represents an 8 byte chunk. what do we multiply by?
global path_multipliers_chunk3: [Field; 32] = [
    /* 0  (00000) */ 0,
    /* 1  (00001) */ 0,
    /* 2  (00010) */ 0,
    /* 3  (00011) */ 0,
    /* 4  (00100) */ 0,
    /* 5  (00101) */ 0,
    /* 6  (00110) */ 0,
    /* 7  (00111) */ 0,
    /* 8  (01000) */ 1,
    /* 9  (01001) */ 1,
    /* 10 (01010) */ 1,
    /* 11 (01011) */ 1,
    /* 12 (01100) */ 1,
    /* 13 (01101) */ 1,
    /* 14 (01110) */ 1,
    /* 15 (01111) */ 1,
    /* 16 (10000) */ 0,
    /* 17 (10001) */ 0,
    /* 18 (10010) */ 0,
    /* 19 (10011) */ 0,
    /* 20 (10100) */ 0,
    /* 21 (10101) */ 0,
    /* 22 (10110) */ 0,
    /* 23 (10111) */ 0,
    /* 24 (11000) */ two_pow_128,
    /* 25 (11001) */ two_pow_128,
    /* 26 (11010) */ two_pow_128,
    /* 27 (11011) */ two_pow_128,
    /* 28 (11100) */ two_pow_128,
    /* 29 (11101) */ two_pow_128,
    /* 30 (11110) */ two_pow_128,
    /* 31 (11111) */ two_pow_128
];

// what do we multiply 4 byte chunk by
global path_multipliers_chunk2: [Field; 32] = [
    /* 0  (00000) */ 0,
    /* 1  (00001) */ 0,
    /* 2  (00010) */ 0,
    /* 3  (00011) */ 0,
    /* 4  (00100) */ 1,
    /* 5  (00101) */ 1,
    /* 6  (00110) */ 1,
    /* 7  (00111) */ 1,
    /* 8  (01000) */ 0,
    /* 9  (01001) */ 0,
    /* 10 (01010) */ 0,
    /* 11 (01011) */ 0,
    /* 12 (01100) */ two_pow_64,
    /* 13 (01101) */ two_pow_64,
    /* 14 (01110) */ two_pow_64,
    /* 15 (01111) */ two_pow_64,
    /* 16 (10000) */ 0,
    /* 17 (10001) */ 0,
    /* 18 (10010) */ 0,
    /* 19 (10011) */ 0,
    /* 20 (10100) */ two_pow_128,
    /* 21 (10101) */ two_pow_128,
    /* 22 (10110) */ two_pow_128,
    /* 23 (10111) */ two_pow_128,
    /* 24 (11000) */ 0,
    /* 25 (11001) */ 0,
    /* 26 (11010) */ 0,
    /* 27 (11011) */ 0,
    /* 28 (11100) */ two_pow_128 * two_pow_64,
    /* 29 (11101) */ two_pow_128 * two_pow_64,
    /* 30 (11110) */ two_pow_128 * two_pow_64,
    /* 31 (11111) */ two_pow_128 * two_pow_64
];

// what do we multiply 2 byte chunk by
global path_multipliers_chunk1: [Field; 32] = [
    /* 0  (00000) */ 0,
    /* 1  (00001) */ 0,
    /* 2  (00010) */ 1,
    /* 3  (00011) */ 1,
    /* 4  (00100) */ 0,
    /* 5  (00101) */ 0,
    /* 6  (00110) */ two_pow_32,
    /* 7  (00111) */ two_pow_32,
    /* 8  (01000) */ 0,
    /* 9  (01001) */ 0,
    /* 10 (01010) */ two_pow_64,
    /* 11 (01011) */ two_pow_64,
    /* 12 (01100) */ 0,
    /* 13 (01101) */ 0,
    /* 14 (01110) */ two_pow_64 * two_pow_32,
    /* 15 (01111) */ two_pow_64 * two_pow_32,
    /* 16 (10000) */ 0,
    /* 17 (10001) */ 0,
    /* 18 (10010) */ two_pow_128,
    /* 19 (10011) */ two_pow_128,
    /* 20 (10100) */ 0,
    /* 21 (10101) */ 0,
    /* 22 (10110) */ two_pow_128 * two_pow_32,
    /* 23 (10111) */ two_pow_128 * two_pow_32,
    /* 24 (11000) */ 0,
    /* 25 (11001) */ 0,
    /* 26 (11010) */ two_pow_128 * two_pow_64,
    /* 27 (11011) */ two_pow_128 * two_pow_64,
    /* 28 (11100) */ 0,
    /* 29 (11101) */ 0,
    /* 30 (11110) */ two_pow_128 * two_pow_64 * two_pow_32,
    /* 31 (11111) */ two_pow_128 * two_pow_64 * two_pow_32
];

// what do we multiply 1 byte chunk by
global path_multipliers_chunk0: [Field; 32] = [
    /* 0  (00000) */ 0,
    /* 1  (00001) */ 1,
    /* 2  (00010) */ 0,
    /* 3  (00011) */ two_pow_16,
    /* 4  (00100) */ 0,
    /* 5  (00101) */ two_pow_32,
    /* 6  (00110) */ 0,
    /* 7  (00111) */ two_pow_16 * two_pow_32,
    /* 8  (01000) */ 0,
    /* 9  (01001) */ two_pow_64,
    /* 10 (01010) */ 0,
    /* 11 (01011) */ two_pow_64 * two_pow_16,
    /* 12 (01100) */ 0,
    /* 13 (01101) */ two_pow_64 * two_pow_32,
    /* 14 (01110) */ 0,
    /* 15 (01111) */ two_pow_64 * two_pow_32 * two_pow_16,
    /* 16 (10000) */ 0,
    /* 17 (10001) */ two_pow_128,
    /* 18 (10010) */ 0,
    /* 19 (10011) */ two_pow_128 * two_pow_16,
    /* 20 (10100) */ 0,
    /* 21 (10101) */ two_pow_128 * two_pow_32,
    /* 22 (10110) */ 0,
    /* 23 (10111) */ two_pow_128 * two_pow_32 * two_pow_16,
    /* 24 (11000) */ 0,
    /* 25 (11001) */ two_pow_128 * two_pow_64,
    /* 26 (11010) */ 0,
    /* 27 (11011) */ two_pow_128 * two_pow_64 * two_pow_16,
    /* 28 (11100) */ 0,
    /* 29 (11101) */ two_pow_128 * two_pow_64 * two_pow_32,
    /* 30 (11110) */ 0,
    /* 31 (11111) */ two_pow_128 * two_pow_64 * two_pow_32 * two_pow_16
];
global tail_path_multipliers_chunk3: [Field; 32] = [0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
global tail_path_multipliers_chunk2: [Field; 32] = [0x01000000000000000000000000000000000000000000000000, 0x01000000000000000000000000000000000000000000000000, 0x01000000000000000000000000000000000000000000000000, 0x01000000000000000000000000000000000000000000000000, 0x00, 0x00, 0x00, 0x00, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x00, 0x00, 0x00, 0x00, 0x010000000000000000, 0x010000000000000000, 0x010000000000000000, 0x010000000000000000, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
global tail_path_multipliers_chunk1: [Field; 32] = [0x0100000000000000000000000000000000000000000000000000000000, 0x0100000000000000000000000000000000000000000000000000000000, 0x00, 0x00, 0x01000000000000000000000000000000000000000000000000, 0x01000000000000000000000000000000000000000000000000, 0x00, 0x00, 0x010000000000000000000000000000000000000000, 0x010000000000000000000000000000000000000000, 0x00, 0x00, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x00, 0x00, 0x01000000000000000000000000, 0x01000000000000000000000000, 0x00, 0x00, 0x010000000000000000, 0x010000000000000000, 0x00, 0x00, 0x0100000000, 0x0100000000, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00];
global tail_path_multipliers_chunk0: [Field; 32] = [0x01000000000000000000000000000000000000000000000000000000000000, 0x00, 0x0100000000000000000000000000000000000000000000000000000000, 0x00, 0x010000000000000000000000000000000000000000000000000000, 0x00, 0x01000000000000000000000000000000000000000000000000, 0x00, 0x0100000000000000000000000000000000000000000000, 0x00, 0x010000000000000000000000000000000000000000, 0x00, 0x01000000000000000000000000000000000000, 0x00, 0x0100000000000000000000000000000000, 0x00, 0x010000000000000000000000000000, 0x00, 0x01000000000000000000000000, 0x00, 0x0100000000000000000000, 0x00, 0x010000000000000000, 0x00, 0x01000000000000, 0x00, 0x0100000000, 0x00, 0x010000, 0x00, 0x01, 0x00];

unconstrained fn __divmod(numerator: Field, denominator: Field) -> (Field, Field) {
    let quotient = numerator as u16 / denominator as u16;
    let remainder = numerator as u16 % denominator as u16;
    (quotient as Field, remainder as Field)
}

unconstrained fn __divmod_u16(numerator: Field, denominator: Field) -> (u16, u16) {
    let quotient = numerator as u16 / denominator as u16;
    let remainder = numerator as u16 % denominator as u16;
    (quotient, remainder)
}

fn divmod(numerator: Field, denominator: Field) -> (Field, Field) {
    // assert(numerator != 0);
    println(f"divmod {numerator}, {denominator}");
    let (quotient, remainder) = __divmod(numerator, denominator);

    let qf = quotient as Field;
    let rf = remainder as Field;

    // note: these range checks are because we know the denominator is 31
    // TODO: need more checks, atm remainder could equal 31
    qf.assert_max_bit_size(14);
    rf.assert_max_bit_size(5);

    // n / d = q
    // d * q + r = n
    assert(qf * denominator as Field + rf == numerator as Field);
    (quotient, remainder)
}

fn divmod_u16(numerator: Field, denominator: Field) -> (u16, u16) {
    // assert(numerator != 0);
    println(f"divmod {numerator}, {denominator}");
    let (quotient, remainder) = __divmod_u16(numerator, denominator);

    let qf = quotient as Field;
    let rf = remainder as Field;

    // note: these range checks are because we know the denominator is 31
    // TODO: need more checks, atm remainder could equal 31
    qf.assert_max_bit_size(14);
    rf.assert_max_bit_size(5);

    // n / d = q
    // d * q + r = n
    assert(qf * denominator as Field + rf == numerator as Field);
    (quotient, remainder)
}
unconstrained fn decompose(val: Field) -> [Field; 16] {
    let mut r: [Field; 16] = [0; 16];

    let mut it = val as u16;
    for i in 0..16 {
        r[i] = (it & 1) as Field;
        it >>= 1;
    }
    r
}

unconstrained fn log2l(val: Field) -> u16 {
    let bits = decompose(val);
    bits[0] as u16
    // let mut r: u16 = 0;
    // for i in 0..16 {
    //     if (bits[i] as bool) {
    //         r = i;
    //     }
    // }
    // r
}

global LIMB_VALID_PATH: [Field; 35] = [
0x000000000, // 0 0 0 0 0 0 0 0 0
0x000000001, // 0 0 0 0 0 0 0 0 1
0x000000003, // 0 0 0 0 0 0 0 1 1
0x000000007, // 0 0 0 0 0 0 1 1 1
0x000000008, // 0 0 0 0 0 1 1 1 1
0x000000010, // 0 0 0 0 1 0 0 0 0
0x000000020, // 0 0 0 1 0 0 0 0 0
0x000000040, // 0 0 1 0 0 0 0 0 0
0x000000080, // 0 1 0 0 0 0 0 0 0
0x000000100, // 1 0 0 0 0 0 0 0 0
0x000000200, // 0 0 0 0 0 0 0 1 0
0x000000400, // 0 0 0 0 0 0 1 0 0
0x000000800, // 0 0 0 0 0 1 0 0 0
0x000001000, // 0 0 0 0 1 0 0 0 0
0x000002000, // 0 0 0 1 0 0 0 0 0
0x000004000, // 0 0 1 0 0 0 0 0 0
0x000008000, // 0 1 0 0 0 0 0 0 0
0x000010000, // 0 0 0 0 0 0 0 0 1
0x000020000, // 0 0 0 0 0 0 0 1 0
0x000040000, // 0 0 0 0 0 0 1 0 0
0x000080000, // 0 0 0 0 0 1 0 0 0
0x000100000, // 0 0 0 0 1 0 0 0 0
0x000200000, // 0 0 0 1 0 0 0 0 0
0x000400000, // 0 0 1 0 0 0 0 0 0
0x000800000, // 0 1 0 0 0 0 0 0 0
0x001000000, // 0 0 0 0 0 0 0 0 1
0x002000000, // 0 0 0 0 0 0 0 1 0
0x004000000, // 0 0 0 0 0 0 1 0 0
0x008000000, // 0 0 0 0 0 1 0 0 0
0x010000000, // 0 0 0 0 1 0 0 0 0
0x020000000, // 0 0 0 1 0 0 0 0 0
0x040000000, // 0 0 1 0 0 0 0 0 0
0x080000000, // 0 1 0 0 0 0 0 0 0
0x100000000,
0x200000000
];

// these path variables describe the location of a limb in an array
// e.g. LAST_LIMB_PATH[5] produces 2^{5-1},
// which is decomposed into 1 0 0 0 0, and the decompositions turned into an array M
// M[4] = 1 i.e. the limbs[4] should contain the last limb
// array extends to 0x200000000 which is 2^33 => 33 31 byte limbs = 1,023 bytes
// this puts a hard limit on the max size of a key that this program supports.
global LAST_LIMB_PATH: [Field; 35] = [
0x000000001, // 0 0 0 0 0 0 0 0 1
0x000000002, // 0 0 0 0 0 0 0 1 0
0x000000004, // 0 0 0 0 0 0 1 0 0
0x000000008, // 0 0 0 0 0 1 0 0 0
0x000000010, // 0 0 0 0 1 0 0 0 0
0x000000020, // 0 0 0 1 0 0 0 0 0
0x000000040, // 0 0 1 0 0 0 0 0 0
0x000000080, // 0 1 0 0 0 0 0 0 0
0x000000100, // 1 0 0 0 0 0 0 0 0
0x000000200, // 0 0 0 0 0 0 0 1 0
0x000000400, // 0 0 0 0 0 0 1 0 0
0x000000800, // 0 0 0 0 0 1 0 0 0
0x000001000, // 0 0 0 0 1 0 0 0 0
0x000002000, // 0 0 0 1 0 0 0 0 0
0x000004000, // 0 0 1 0 0 0 0 0 0
0x000008000, // 0 1 0 0 0 0 0 0 0
0x000010000, // 0 0 0 0 0 0 0 0 1
0x000020000, // 0 0 0 0 0 0 0 1 0
0x000040000, // 0 0 0 0 0 0 1 0 0
0x000080000, // 0 0 0 0 0 1 0 0 0
0x000100000, // 0 0 0 0 1 0 0 0 0
0x000200000, // 0 0 0 1 0 0 0 0 0
0x000400000, // 0 0 1 0 0 0 0 0 0
0x000800000, // 0 1 0 0 0 0 0 0 0
0x001000000, // 0 0 0 0 0 0 0 0 1
0x002000000, // 0 0 0 0 0 0 0 1 0
0x004000000, // 0 0 0 0 0 0 1 0 0
0x008000000, // 0 0 0 0 0 1 0 0 0
0x010000000, // 0 0 0 0 1 0 0 0 0
0x020000000, // 0 0 0 1 0 0 0 0 0
0x040000000, // 0 0 1 0 0 0 0 0 0
0x080000000, // 0 1 0 0 0 0 0 0 0
0x100000000,
0x200000000,
0x400000000
];

global LAST_LIMB_PATHV2: [Field; 35] = [
0x000000000, // 0 0 0 0 0 0 0 0 1
0x000000001, // 0 0 0 0 0 0 0 1 0
0x000000003, // 0 0 0 0 0 0 1 0 0
0x000000007, // 0 0 0 0 0 1 0 0 0
0x00000000f, // 0 0 0 0 1 0 0 0 0
0x00000001f, // 0 0 0 1 0 0 0 0 0
0x00000003f, // 0 0 1 0 0 0 0 0 0
0x00000007f, // 0 1 0 0 0 0 0 0 0
0x0000000ff, // 1 0 0 0 0 0 0 0 0
0x0000001ff, // 0 0 0 0 0 0 0 1 0
0x0000003ff, // 0 0 0 0 0 0 1 0 0
0x0000007ff, // 0 0 0 0 0 1 0 0 0
0x000000fff, // 0 0 0 0 1 0 0 0 0
0x000001fff, // 0 0 0 1 0 0 0 0 0
0x000003fff, // 0 0 1 0 0 0 0 0 0
0x000007fff, // 0 1 0 0 0 0 0 0 0
0x00000ffff, // 0 0 0 0 0 0 0 0 1
0x00001ffff, // 0 0 0 0 0 0 0 1 0
0x00003ffff, // 0 0 0 0 0 0 1 0 0
0x00007ffff, // 0 0 0 0 0 1 0 0 0
0x0000fffff, // 0 0 0 0 1 0 0 0 0
0x0001fffff, // 0 0 0 1 0 0 0 0 0
0x0003fffff, // 0 0 1 0 0 0 0 0 0
0x0007fffff, // 0 1 0 0 0 0 0 0 0
0x000ffffff, // 0 0 0 0 0 0 0 0 1
0x001ffffff, // 0 0 0 0 0 0 0 1 0
0x003ffffff, // 0 0 0 0 0 0 1 0 0
0x007ffffff, // 0 0 0 0 0 1 0 0 0
0x00fffffff, // 0 0 0 0 1 0 0 0 0
0x01fffffff, // 0 0 0 1 0 0 0 0 0
0x03fffffff, // 0 0 1 0 0 0 0 0 0
0x07fffffff, // 0 1 0 0 0 0 0 0 0
0x0ffffffff,
0x1ffffffff,
0x3ffffffff
];

global LOG2: [u32; 35] = [
0,
1,
2,
2,
3,
3,
3,
3,
4,
4,
4,
4,
4,
4,
4,
4,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
6,
6,
];

global NUM_BYTES_MOD_31_IS_ZERO: [Field; 31] = [
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
];

pub fn get_last_limb_path_v2<let OutputFields: u16>(last_limb_index: Field) -> [Field; OutputFields] {
    let path = LAST_LIMB_PATHV2[last_limb_index]; // 2

    // 2 limbs, last limb = 1, path = [1 0]
    // 3 limbs, last limb = 2, path = [1 0 0]
    // for 3 limbs. limb idx[0] = 1, limb idx[1] = 1
    // last limb * 2 - 1 = 3 = [0 1 1]
    // 
    //let valid_limb_path = path - 1;
    // if last limb = 1 we want result[1] to contain last limb
    // right now, high bit is 0
    // path - 1
    // 3 limbs path = [1 0 0]
    // valid = [0 1 1]
    // 2^2 - 1
    // 4 limbs path =[1 0 0 0]
    // valid = [0 1 1 1]
    // 2^3 - 1

    // 2^{last_limb_index - 1}
    // let path_bits = decompose(path);
    let path_valid_bits = decompose(path);
    // let mut sum: Field = 0;
    let mut path_valid_sum: Field = 0;
    // let mut path_output: [Field; OutputFields] = [0; OutputFields];
    let mut path_valid_output: [Field; OutputFields] = [0; OutputFields];
    for i in 0..OutputFields {
        // let k = path_bits[i];
        // println(f"path bit[{i}] = {k}");
        // assert(path_bits[i] * path_bits[i] - path_bits[i] == 0);
        assert(path_valid_bits[i] * path_valid_bits[i] - path_valid_bits[i] == 0);

        // sum += path_bits[i] * ((i as Field));
        path_valid_sum += (path_valid_bits[i] * (1 << i as u8) as Field);
        // path_output[i] = path_bits[i];
        path_valid_output[i] = path_valid_bits[i];
    }
    // println(f"sum {sum}");
    // println(f"last limb index {last_limb_index}");
    // assert(sum == last_limb_index); // 1 gate
    // TODO need to assert some kind sum here
    assert(path_valid_sum == path); // erm this right?
    path_valid_output
}

pub fn get_last_limb_path<let OutputFields: u16>(last_limb_index: Field) -> ([Field; OutputFields], [Field; OutputFields]) {
    let path = LAST_LIMB_PATH[last_limb_index]; // 2

    // 2 limbs, last limb = 1, path = [1 0]
    // 3 limbs, last limb = 2, path = [1 0 0]
    // for 3 limbs. limb idx[0] = 1, limb idx[1] = 1
    // last limb * 2 - 1 = 3 = [0 1 1]
    // 
    //let valid_limb_path = path - 1;
    // if last limb = 1 we want result[1] to contain last limb
    // right now, high bit is 0
    // path - 1
    // 3 limbs path = [1 0 0]
    // valid = [0 1 1]
    // 2^2 - 1
    // 4 limbs path =[1 0 0 0]
    // valid = [0 1 1 1]
    // 2^3 - 1

    // 2^{last_limb_index - 1}
    let path_bits = decompose(path);
    let path_valid_bits = decompose(path - 1);
    let mut sum: Field = 0;
    let mut path_valid_sum: Field = 0;
    let mut path_output: [Field; OutputFields] = [0; OutputFields];
    let mut path_valid_output: [Field; OutputFields] = [0; OutputFields];
    for i in 0..OutputFields {
        let k = path_bits[i];
        println(f"path bit[{i}] = {k}");
        assert(path_bits[i] * path_bits[i] - path_bits[i] == 0);
        assert(path_valid_bits[i] * path_valid_bits[i] - path_valid_bits[i] == 0);

        sum += path_bits[i] * ((i as Field));
        path_valid_sum += (path_valid_bits[i] * (1 << i as u8) as Field);
        path_output[i] = path_bits[i];
        path_valid_output[i] = path_valid_bits[i];
    }
    println(f"sum {sum}");
    println(f"last limb index {last_limb_index}");
    assert(sum == last_limb_index); // 1 gate
    // TODO need to assert some kind sum here
    assert(path_valid_sum == path - 1); // erm this right?
    (path_output, path_valid_output)
}

// end = current is 0 and previous is 1
// (1 - path[i]) * path[i - 1]
/*
ok how do we rearchitect to reduce gate count?

can we ... hmm what can we do

set previous = 0 and immediately start a loop
*/
global SliceFieldsNumSlices = 3;
fn slice_fields<let InputFields: u16, let OutputFields: u16>(data: [Field; InputFields], start_byte: u16, num_bytes: u16) -> [Field; OutputFields] {
    let (start_index_u16, start_mod_31_u16) = divmod_u16(start_byte as Field, 31);
    let start_index = start_index_u16 as Field;
    let start_mod_31 = start_mod_31_u16 as Field;
    let num_underflow_bytes = start_mod_31;

    // start = 38. mod 31 = 7
    // start_mod_31_u16 = num bytes consumed by 

    // 38 mod 31 = 7. so 1st head = 24, tail = 7
    // instead of 31 we need std::max(31, num_bytes)
    // (num_bytes / 31) == 0
    let mut num_unused_bytes_in_start_limb = 31 - start_mod_31_u16;

    let lt_predicate = num_bytes < num_unused_bytes_in_start_limb;
    let num_unused_bytes_in_start_limb = (num_bytes as Field - num_unused_bytes_in_start_limb as Field) * lt_predicate as Field
        + num_unused_bytes_in_start_limb as Field;
    // if (num_bytes < num_unused_bytes_in_start_limb) {
    //     num_unused_bytes_in_start_limb = num_bytes;
    // }
    let mut num_remaining_bytes = num_bytes as Field - num_unused_bytes_in_start_limb as Field;
    // todo fix
    let bytes_fit_into_limb = (31 - start_mod_31_u16) >= num_bytes;
    // if a single limb we want num_overflow_bytes to equal num_bytes + start_mod_31
    // remaining bytes mod 31

    let (num_whole_limbs_u16, num_overflow_bytes_u16) = divmod_u16(num_remaining_bytes, 31);
    let num_whole_limbs = num_whole_limbs_u16 as Field;
    let num_overflow_bytes = num_overflow_bytes_u16 as Field;
    let (_, tail) = slice_field(data[start_index], num_underflow_bytes);

    let mut previous = tail;
    // first chunk is tail
    let mut num_whole_limbs = num_whole_limbs as u16; // todo fix

    let mut result = [0; OutputFields];

    let mut extra_head_section = (num_overflow_bytes_u16 > start_mod_31_u16) & !bytes_fit_into_limb;
    num_whole_limbs += extra_head_section as u16;
    // 31, 31, 4
    // 4 overflow bytes. 2 bytes in start limb

    let (num_bytes_div_31, num_bytes_mod_31) = divmod(num_bytes as Field, 31);
    // let num_bytes_mod_31_is_0 = (num_bytes_mod_31 == 0) as Field;

    let num_bytes_mod_31_is_0 = NUM_BYTES_MOD_31_IS_ZERO[num_bytes_mod_31]; // (num_bytes_mod_31 == 0) as Field;
    let index_of_output_limb: Field = num_bytes_div_31 - num_bytes_mod_31_is_0;

    // let (path, path_valid_output): ([Field; OutputFields], [Field; OutputFields]) = get_last_limb_path(index_of_output_limb);
    let path_valid_output: [Field; OutputFields] = get_last_limb_path_v2(index_of_output_limb);

    let tail_shift = BYTE_SHIFT[num_unused_bytes_in_start_limb];

    // so we have input fields which is a 16 bit value (11 bits really)
    // and we have data index which is similar
    /*
        ok so we can get path_valid
    */
    for i in 0..(OutputFields - 1) {
        // ok so... we start with a partial limb
        // we then have K number of whole limbs
        /*
        let slice_valid = (i < num_whole_limbs) as Field;
        // let mut data_index = (start_index_u16_plus_1 + i);
        // let no_data: Field = (data_index >= InputFields) as Field;
        //let data_index = (data_index as Field); // * (1 - no_data); // prevents array overflow
        let input_slice = data[start_index + 1 + i as Field]; // * slice_valid; // * (1 - no_data as Field);
        let (head, tail) = slice_field(input_slice, num_underflow_bytes);
        let combined = previous * tail_shift + head;
        result[i] = combined * slice_valid;
    */
        // let slice_valid = (i < num_whole_limbs) as Field;
        // let mut data_index = (start_index_u16_plus_1 + i);
        // let data_index = (data_index as Field); //  * (1 - no_data); // prevents array overflow
        // let input_slice = data[data_index]; // * slice_valid; //  * (1 - no_data as Field);
        // let (head, tail) = slice_field(input_slice, num_underflow_bytes);
        // let combined = previous * tail_shift + head;
        // result[i] = combined; // * slice_valid;
        // previous = tail;
        // previous = (tail - previous) * slice_valid + previous;
        // previous = (tail - previous) * slice_valid + previous;
        // THIS VERSION WORKS
        let slice_valid = path_valid_output[i];
        //  let slice_valid_other = (i < num_whole_limbs) as Field;
        let mut data_index = (start_index + 1 + i as Field);
        // let no_data = (data_index >= InputFields) as Field;
        let data_index = (data_index as Field); // * (1 - no_data); // prevents array overflow
        let input_slice = data[data_index]; //* slice_valid; // * (1 - no_data as Field);
        let (head, tail) = slice_field(input_slice, num_underflow_bytes);
        let combined = previous * tail_shift + head;
        result[i] = combined * slice_valid;

        previous = (tail - previous) * slice_valid + previous;
    }

    /*
    let (_, num_bytes_mod_31) = divmod(num_bytes as Field, 31);

    // let num_bytes_mod_31_is_0 = (num_bytes_mod_31 == 0) as Field;
    // let index_of_output_limb = num_bytes_div_31 - num_bytes_mod_31_is_0;

    let slice_size = (num_bytes as Field + start_mod_31) * bytes_fit_into_limb as Field + num_overflow_bytes;

    //let use_previous_for_last_limb = (!bytes_fit_into_limb & extra_head_section) | (bytes_fit_into_limb);

    //let mut index_of_overflow_limb = start_index as Field + num_whole_limbs as Field + 1 - extra_head_section as Field;
    // index_of_overflow_limb *= (1 - use_previous_for_last_limb as Field); // prevents index exceeding array size
    // let last_limb_from_data = data[index_of_overflow_limb];

    // let slice_source = (previous - last_limb_from_data) * use_previous_for_last_limb as Field + last_limb_from_data;

    let mut (head, _) = slice_field(previous, slice_size);
    let mut last_limb = head + (previous * BYTE_SHIFT[31 - num_overflow_bytes]); // * (1 - use_previous_for_last_limb as Field);
    last_limb *= BYTE_SHIFT[num_bytes_mod_31];
    result[0] = last_limb;
    */
    // THIS VERSION WORKS

    let slice_size = (num_bytes as Field + start_mod_31) * bytes_fit_into_limb as Field + num_overflow_bytes;

    let use_previous_for_last_limb = (!bytes_fit_into_limb & extra_head_section) | (bytes_fit_into_limb);

    let mut index_of_overflow_limb = start_index as Field + num_whole_limbs as Field + 1 - extra_head_section as Field;
    index_of_overflow_limb *= (1 - use_previous_for_last_limb as Field); // prevents index exceeding array size
    let last_limb_from_data = data[index_of_overflow_limb];

    let slice_source = (previous - last_limb_from_data) * use_previous_for_last_limb as Field + last_limb_from_data;

    let mut (head, _) = slice_field(slice_source, slice_size);
    let mut last_limb = head
        + (previous * BYTE_SHIFT[31 - num_overflow_bytes]) * (1 - use_previous_for_last_limb as Field);
    last_limb *= BYTE_SHIFT[num_bytes_mod_31];

    // result[0] = last_limb;
    // 26,583 (no last limb set)
    // 27,883 (new last limb set) delta = 1,300 = 13 boo
    // 28,323 (old last limb set) delta 117 + 323 = 540 = 5.4

    // We have two parameters, `i`, `index_of_output_limb`
    // (or more generally `i` and `num_bytes`)
    // these are indexing needle elements so not large
    // we can have some table. a 2D table of is_same[i][j]
    // flattened to 1D via is_same[i * OutputFields + j]
    // would be 3 gates to access which seems painful
    // +2 gates to set
    // is 5 gates per iteration * 2 = 10. current is 13
    /*
        can we do better w. unconstrained fn?

        (i - index) if zero then we want last_limb
        (i - index) if not zero
    */
    // let path = LAST_LIMB_PATH[index_of_output_limb];
    // let path_bools = decompose(index_of_output_limb as u16);
    // let num_bits = log2(OutputFields);

    // let mut r: Field = 0;
    // for i in 0..num_bits {
    //     r *= 2;
    //     r += bit_bools[i] as Field;
    // }
    // assert(r == index_of_output_limb);
    // this right? not sure
    /*
        use index of output limb to get a path 0 0 1 0
    */

    // 27983
    // 883 vs 983

    // 4 gates per it
    // i == x
    // (a - b) * is_eq = 0
    // ((a - b) * I - 1) * (1 - is_eq) = 0

    // diff = (a - b)
    // diff * is_eq + (diff * I - 1) * is_eq (3 gates each surely?)
    // 5 gates there is rounding error?

    // getting the path...
    // PA, PB
    // PA + PB * 2 == Sum = 1 gate
    // PA bool (1 gate)
    // PB bool (1 gate)
    // read = 2 gates

    // 0 1 1
    // 1 0 0

    // 0 0
    // 0 1
    // current = 0 and previous = 1
    // 27983
    // 5 gates
    let mut path: [Field; OutputFields] = [0; OutputFields];
    for i in 1..OutputFields {
        path[i] = (1 - path_valid_output[i]) * path_valid_output[i-1];
    }
    path[0] = (1 - path_valid_output[0]);
    for i in 0..OutputFields {
        //let is_last = (i as Field == index_of_output_limb) as Field;
        let is_last = path[i];
        result[i] = (last_limb - result[i]) * is_last + result[i];
    }
    // if (!bytes_fit_into_limb & extra_head_section) | (bytes_fit_into_limb) {
    //     let (head, _) = slice_field(slice_source, slice_size);

    //     result[index_of_output_limb] = head * BYTE_SHIFT[num_bytes_mod_31];
    // } else {
    //     let mut (head, _) = slice_field(slice_source, slice_size);

    //     let last_limb = (previous * BYTE_SHIFT[31 - num_overflow_bytes] + head) * BYTE_SHIFT[num_bytes_mod_31];

    //     // let mut last_limb = combined * (1 - perfectly_aligned as Field) + previous * perfectly_aligned as Field;
    //     // let num_bytes_in_last_limb = num_bytes % 31;
    //     // last_limb *= BYTE_SHIFT[num_bytes_in_last_limb];
    //     result[index_of_output_limb] = last_limb;
    // }
    // 38 mod 31 = 7
    // limb[1] 7 bytes in
    result
}

// 32 position, 68 bytes
// x[30] = last in 1st limb
// x[31] = 1st in 2nd limb
// x[32] = 2nd in 2nd limb => 30 bytes in start limb = 0x1e
// 38 remaining bytes, 1 whole limb, 7 overflow bytes
// limbs[1] = first partial
// limbs[2] = whole
// limbs[3] = exit
// start = 1 on 30
// whole = 1 on 30

// when computing the whole limb, previous = 30 byte hoohah
// head = 0x6c. (previou * 0x100 + head). we do that
// we cache previous as 0x6420627... etc (30 byte chunk)
// final slice. we have 7 overflow bytes
// 1 byte goes into the previous chunk
// 6 bytes go into the final chunk
// oh. nasty. hmmmmm can we handle in main loop by going an extra iteration and performing a mask?

unconstrained fn build_slices<let N: u32>(bytes: [u8; N], start: u32, num_bytes: u32) -> [Field; 3] {
    let mut slices: [Field; 3] = [0; 3];
    for i in 0..3 {
        for k in 0..31 {
            let mut idx = i * 31 + k;
            slices[i] *= 0x100;
            if (idx < num_bytes) {
                slices[i] += bytes[idx + start] as Field;
            }
        }
    }
    slices
}

#[test]
fn test_slice_fields() {
    let text: [u8; 1405] = "Charlie is genius, right. He's made from a million pieces of old bubble gum. Imagine that! In the summer of 1976, on his way home from an Alice Cooper concert, Charlie started to melt onto the pavement. It was too hot in L.A., and he melted like a pink bitch. Luckily though, there was Eric Phillips, a local crocodile who dabbled in black magic. He took pity on Charlie and scraped him off the floor with a pair of fish slicers. He poured him into an antique soup ladle, and boarded his magic carpet. Destination: Alaska! Eric Phillips decided to refreeze Charlie, but in his cold-blooded reptilian haste, he refroze him into to the shape of a Hoover. Charlie wasn't fazed though, he just zoomed about the place, sucking up Inuits. Ha ha! Oh. The Inuits didn't mind; they loved it in Charlie's pink, tight warm belly pouch, and they refused to come out. Charlie said, \"I'm cool with that,\" and set fire to a posh hammer to make it official. he downside was that the Inuits suffocated immediately. It was air-tight in there. Charlie panicked and fired the tiny Inuit bullets into Eric's crocodile peepers. The green shape was frozen. After a quick drink, Charlie stole Eric Phillips's magic carpet and left for Seattle. Charlie was racked with guilt: he'd killed 50 Inuits, noone needs that. He decided to spend the rest of his life putting small hairstyles onto boots, monkey nuts, trumpets and spanners.".as_bytes();
    println(f"text = {text}");
    let mut slices: [Field; 46 + 3] = [0; 46 + 3];
    for i in 0..46 {
        for j in 0..31 {
            let mut idx = i * 31 + j;
            slices[i] *= 0x100;
            if (idx < 1405) {
                slices[i] += text[idx] as Field;
            }
        }
    }
    // let start_byte = 26;

    let byte_sizes: [u32; 10] = [
        1,
        5,
        30,
        31,
        37,
        44,
        61,
        62,
        63,
        90
    ];

    let byte_positions: [u32; 18] = [
        0,
        1,
        14,
        15,
        16,
        20,
        28,
        29,
        30,
        31,
        32,
        33,
        38,
        40,
        55,
        60,
        61,
        62
    ];

    for i in 0..10 {
        let num_bytes = byte_sizes[i];
        for j in 0..18 {
            let start_byte: u32 = byte_positions[j];
            let mut expected_slices: [Field; 3] = build_slices(text, start_byte, num_bytes);
            let result_slices: [Field; 3] = slice_fields(slices, start_byte as u16, num_bytes as u16);
            assert(result_slices == expected_slices);
        }

        for j in 0..18 {
            let start_byte: u32 = text.len() - num_bytes - byte_positions[j];
            let mut expected_slices: [Field; 3] = build_slices(text, start_byte, num_bytes);
            let result_slices: [Field; 3] = slice_fields(slices, start_byte as u16, num_bytes as u16);
            assert(result_slices == expected_slices);
        }
    }
}

fn slice_field(f: Field, num_bytes: Field) -> (Field, Field) {
    let chunks = __slice_field(f, num_bytes);
    chunks[0].assert_max_bit_size(8);
    chunks[1].assert_max_bit_size(16);
    chunks[2].assert_max_bit_size(32);
    chunks[3].assert_max_bit_size(64);
    chunks[4].assert_max_bit_size(128);

    let mut head: Field = 0;
    let mut tail: Field = 0;

    let temp = path_multipliers_chunk4[num_bytes];
    head = chunks[4] * temp;
    std::as_witness(head);
    head += chunks[3] * path_multipliers_chunk3[num_bytes];
    std::as_witness(head);
    head += chunks[2] * path_multipliers_chunk2[num_bytes];
    std::as_witness(head);
    head += chunks[1] * path_multipliers_chunk1[num_bytes];
    std::as_witness(head);
    head += chunks[0] * path_multipliers_chunk0[num_bytes];

    tail = chunks[4] * (1 - temp);
    std::as_witness(tail);
    tail += chunks[3] * tail_path_multipliers_chunk3[num_bytes];
    std::as_witness(tail);
    tail += chunks[2] * tail_path_multipliers_chunk2[num_bytes];
    std::as_witness(tail);
    tail += chunks[1] * tail_path_multipliers_chunk1[num_bytes];
    std::as_witness(tail);
    tail += chunks[0] * tail_path_multipliers_chunk0[num_bytes];

    let total = tail + head * BYTE_SHIFT[num_bytes];
    assert(total == f);
    (head, tail)
}

#[test]
fn test_slice_field() {
    let input = 0xffeebbccbbaa99887766554433221100112233445566778899aabbccddeeff;

    let input_bytes: [u8; 32] = input.to_be_bytes(32).as_array();

    for i in 0..32 {
        println(f"i = {i}");
        let num_bytes = i as Field;
        let (head, tail) = slice_field(input, num_bytes);
        let mut expected_head: Field = 0;
        let mut expected_tail: Field = 0;
        for j in 0..num_bytes as u32 {
            expected_head *= 0x100;
            expected_head += input_bytes[j + 1] as Field;
        }
        for j in 0..(31 - num_bytes as u32) {
            expected_tail *= 0x100;
            expected_tail += input_bytes[j as Field + num_bytes + 1] as Field;
        }
        assert(expected_head == head);
        assert(expected_tail == tail);
    }
    let (head, tail) = slice_field(input, 11);
    let head_expected = 0xffeebbccbbaa9988776655;
    let tail_expected = 0x4433221100112233445566778899aabbccddeeff;
    assert(head_expected == head);
    assert(tail_expected == tail);
}


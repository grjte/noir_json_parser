
    fn sort_predicate(_lhs: Field, _rhs: Field) -> bool {

        let lhs = JSONEntry::from_field(_lhs);
        let rhs = JSONEntry::from_field(_rhs);
        let depth_lt = lt_field_8_bit(lhs.depth, rhs.depth);
        let json_lt = lt_field_16_bit(lhs.json_pointer, rhs.json_pointer);
        let depth_eq = lhs.depth == rhs.depth;

        let lt = depth_lt | (depth_eq & json_lt);
        lt
    }

    fn unconditional_sort_predicate(_lhs: Field, _rhs: Field) {
        // TODO this can be much more efficient!
        let lhs = JSONEntry::from_field(_lhs);
        let rhs = JSONEntry::from_field(_rhs);
        let depth_lt = lt_field_8_bit(lhs.depth, rhs.depth);
        let json_lt = lt_field_16_bit(lhs.json_pointer, rhs.json_pointer);
        let depth_eq = lhs.depth == rhs.depth;
        let json_eq = lhs.json_pointer == rhs.json_pointer;
        let lt = depth_lt | (depth_eq & (json_lt | json_eq));
        assert(lt == true);
    }

        fn grammar_check_2(&mut self) {
        let mut previous: TranscriptEntry = TranscriptEntry::new();
        let mut current: TranscriptEntry = TranscriptEntry::new();

        previous = TranscriptEntry::from_field(self.transcript[0]);
        let mut is_object = true;
        let mut expect_value = false;
        for i in 1..TranscriptEntries {
            current = TranscriptEntry::from_field(self.transcript[i]);

            if (current.token == KEY_SEPARATOR_TOKEN) {
                assert(previous.token == STRING_TOKEN, "key separator token error");
                expect_value = true;
            }

            if (previous.token == KEY_SEPARATOR_TOKEN) {
                assert(
                    (current.token == STRING_TOKEN)
                    | (current.token == NUMERIC_TOKEN)
                    | (current.token == LITERAL_TOKEN)
                    | (current.token == BEGIN_OBJECT_TOKEN)
                    | (current.token == BEGIN_ARRAY_TOKEN), "expected value"
                );
            }

            if (current.token == VALUE_SEPARATOR_TOKEN) {
                assert(is_value(previous.token), "value separator without previous value");
            }

            if (is_value(previous.token)) {
                assert(is_value_delimiter(current.token));
            }
            // check key
        }
    }

    fn sort_json_entries(&mut self) {
        // make this member of struct
        let mut compressed: [Field; TranscriptEntries] = [0; TranscriptEntries];
        for i in 0..TranscriptEntries {
            compressed[i] = self.json_entries[i].to_field();
        }
        let sort_result = noir_sort::sort_advanced(
            compressed,
            JSONEntry::sort_predicate,
            JSONEntry::unconditional_sort_predicate
        );
        let sort_indices = sort_result.sort_indices;
        let mut sorted = sort_result.sorted;

        let mut sorted_entries: [JSONEntry; TranscriptEntries] = [JSONEntry::new(); TranscriptEntries];

        for i in 0..TranscriptEntries {
            sorted_entries[i] = JSONEntry::from_field(sorted[i]);
        }

        for i in 0..TranscriptEntries {
            let old_child_pointer = sorted_entries[i].child_pointer;

            let new_child_pointer = sort_indices[old_child_pointer];
            // TODO: hacky workaround, fix
            if (old_child_pointer != 0) {
                sorted_entries[i].child_pointer = new_child_pointer;
            }
        }
        self.json_entries = sorted_entries;
    }
